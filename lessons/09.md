# Lesson 9
## Routes for creating, updating and deleting data

| Lesson objectives                            | Course objectives                        |
|:---------------------------------------------|:-----------------------------------------|
| Design and implement POST, PUT/PATCH | Design and implement CRUD routes in a Rails app | 
| Validate user form input and respond with informative error messages | Test a Rails app using automated and manual test | 
| Test your routes with Rspec request specs | |

Let's review the list of requirements for the Dream of Code app:

1. We'd like a dashboard that lists the courses for the current and upcoming trimester. :checkmark:
2. Each of those courses should link to a page that shows the list of enrolled students (for current courses). :checkmark:
3. On the dashboard, there should be a link to a form for adding a new course.
4. On each course page, there should be a link to a form to enroll a student in the course.
5. We need to be able to update the application deadline for the upcoming trimester.
6. Only Dream of Code staff should be able to view student enrollments, create courses and update trimesters.
7. We need API endpoints to integrate with external apps. 
  a. We need an endpoint that returns current course data.
  b. We need an endpoint that returns student enrollment data in a specific format (per course).

This week, we'll implement #3 and #4. You'll do #5 on your own for your assignment.

### Creating a new course form
Here's a wireframe for how our form might look:

TODO wireframe

Notice we'll need a route that displays a form, then we'll also need a route for the form submission. When we click "submit" on the form, we expect that a new course is created.

Let's revisit our steps to create a (GET) route:
1. Define the route, and map the route to a controller and action
2. Respond to the request with HTML (an outline with static data at first)
3. Collect the data we want to display and include that in our HTML reponse

The route to display the form is reading and displaying data, so we'll use the GET verb for that route. But the route for the form submission should create data, so we should define that route to expect the POST verb or method. The steps to create a POST or PUT route are a little different:

1. Define the route, and map the route to a controller and action
2. Create the new data if possible
  a. Respond with a success message if the new data is created and redirect to a new route.
  b. Respond with an appropriate error message if the new data is not created and redirect back to the form.

### The route to display the form:
1. HTTP Method
  - As mentioned, we'll use GET.
2. Path
  - Since we are creating a new resource (a course), we should follow the convention in [this table](https://guides.rubyonrails.org/routing.html#crud-verbs-and-actions). So our path will be `/courses/new`.
3. Controller and action
  - Again, since we are defining "resourceful routes", we should follow Rails conventions, which says our controller will be `courses_controller.rb` and the action will be `new`.

### The route for form submission:
1. HTTP Method
  - As mentioned, we'll use POST.
2. Path
  - Since we are creating a new resource (a course), we should follow the convention in [this table](https://guides.rubyonrails.org/routing.html#crud-verbs-and-actions). So our path will be `/courses`.
3. Controller and action
  - Again, since we are defining a "resourceful route", we should follow Rails conventions, which says our controller will be `courses_controller.rb` and the action will be `create`.

You'll see in the app that the `courses_controller.rb` already exists, as does a `new` action and a `new` view. The routes are also already set up in `config/routes.rb`. Visit `http://localhost:3000/courses/new` to verify the form displays.

Since we have the routes and HTML set up, we can focus on what should happen in the `create` controller action.

Recall creating a new `Course` record in early lessons in the rails console. We used the `ActiveRecord` class method `create` or `create!` and passed a hash of attributes and values, like this:

```
Course.create!(trimester_id: 3, coding_class_id: 5, max_enrollment: 20)
```

So we'll need to do that in the `create` action, using the values passed in from the form submission.

Let's use a debugger statement in the action to see what the data from the form looks like. Review the parameters section of [Rails Guides](https://guides.rubyonrails.org/action_controller_overview.html#parameters) to get an understanding of how post data is made available in controllers.

In the courses controller, `create` action, add a debugger statement:

```
def create
  debugger
end
```

Now return to the form in your browser, fill in the form and submit. In the terminal window where your app is running, you'll see something similar to a rails console prompt.

This environment is very similar to rails console, but we have all the context and variables available that are in scope at the point in code where the debugger statement lives. The deubber statement instructs the Rails server to stop code execution at that line and essentially start a rails console instance. According to Rails Guides, we should be able to access a variable called `params`, which should contain the POST data from the form. 

```
    23|   def create
=>  24|     debugger
    25|   
    26|   end
    27|   
=>#0	CoursesController#create at ~/src/ctd-rails/doc-fullstack/app/controllers/courses_controller.rb:24
  #1	ActionController::BasicImplicitRender#send_action(method="create", args=[]) at ~/.asdf/installs/ruby/3.3.6/lib/ruby/gems/3.3.0/gems/actionpack-8.0.1/lib/action_controller/metal/basic_implicit_render.rb:8
  # and 64 frames (use `bt' command for all frames)
(rdbg)
```
You'll see the cursor at the end of the last line. Type `params`

```
  # and 64 frames (use `bt' command for all frames)
(rdbg) params
#<ActionController::Parameters {"authenticity_token"=>"rNd1NvN5QLHUaiPBlHOI5Isy4xpDAtLmxCIyndKXTGjeItppP-rAwlIQF9ZbO5l3G7SKDhBpWI8G47PSYkHSrw", "course"=>{"coding_class_id"=>"3", "trimester_id"=>"8", "max_enrollment"=>"25"}, "commit"=>"Create Course", "controller"=>"courses", "action"=>"create"} permitted: false>
```

The output here is another syntax for a ruby hash. The arrows are called "hashrockets". The important thing to focus on in this output is the hash assigned to "course".

```
"course"=>{"coding_class_id"=>"3", "trimester_id"=>"8", "max_enrollment"=>"25"}
```

Written in the usual syntax:
```
course: {coding_class_id: "3", trimester_id: "8", max_enrollment: "25"}
```

These should contain the values you entered in the form. This is also exactly the hash we would pass to `Course.create`. So `params[:course]` contains the hash we'll use to create the new Course record:

```
Course.create!(params[:course])
```

We won't cover the details of this now, but it's important to know that we should be explicit about which parameters we allow a user to submit for creation and update of a resource. Imagine we have a column called "secret" that should only be edited by an admin. A malicious user could submit a post request with an attribute called secret, and if we blindly pass the entire set of post data to the resource, we'd allow the user to update `secret`. So, in every controller, we explicitly define the parameters we'll permit the user to update for that resource. You can read more about this in the [Rails Guides here](https://guides.rubyonrails.org/action_controller_overview.html#strong-parameters).

At the end of courses controller, you'll find a method called `course_params`. This method returns a copy of `params[:course]` in which any unpermitted attributes (any attributes that don't appear in the list defined in this method), are filtered out of the hash. So it's safe to use `course_params` -- let's replace it now.

```
  def create
    debugger
    @course = Course.create!(course_params)

  end
```

Now we'll just need to tell Rails how to respond to the post request. After creating a new resource, it's typical to redirect the user to the show page for that resource. Let's do that following succesful creation. By convention, Rails will assume the show page for a resource when it's passed to `redirect_to`. We won't go into detail about the `respond_to` block here, but it's enough to know that in the form submission request, `format.html` will determine the next action. So we should see the page redirect to the course show page.

```
  def create
    @course = Course.create!(course_params)

    respond_to do |format|
      format.html { redirect_to @course, notice: "Course was successfully created." }
      format.json { render :show, status: :created, location: @course }
    end
  end
```

We won't talk a lot about the `notice` message that displays, but you may read more about flash messages [here in the Rails Guide](https://guides.rubyonrails.org/action_controller_overview.html#the-flash)s.

Notice we also removed the debugger statement from the method. In the console (where we were debugging), type "exit" and hit enter to exit the breakpoint or debug mode.

Now let's try the form again. Go to `http://localhost:3000/courses/new`, complete the form and submit. Do you see the show page for the course you just added? Try this...in the form, submit a value for `Coding class` that does not correspond to a coding class id. Something like 800 should work. When you submit the form, you should see an error with this text.

```
ActiveRecord::RecordInvalid in CoursesController#create
Validation failed: Coding class must exist
```

We know why the form submission failed, but we wouldn't want a user to get an error page like this if they type the wrong coding class id. Instead, we'd like to report to them that the id they chose does not exist, so they need to make another choice. We call this "validation".

#### Validation

Instead of using the `create!` method, we can create a new `Course` in memory, then decide to show the course page if it saves successfully, and we'll show the form again with some errors otherwise. We'll use `Course.new` to create a new in-memory course, and we'll pass the attributes from the form.

```
  def create
    @course = Course.new(course_params)

    respond_to do |format|
      format.html { redirect_to @course, notice: "Course was successfully created." }
      format.json { render :show, status: :created, location: @course }
    end
  end
```

When we call `.save` on an `ActiveRecord` instance, validations are called on that instance, and if any validations fail, errors are added to an attribute (called `errors`) on the instance. Read sections 1 - 1.5 of the [Rails Guides on validations](https://guides.rubyonrails.org/active_record_validations.html) for an overview.

```
  def create
    @course = Course.new(course_params)

    respond_to do |format|
      if @course.save
        # Redirect to the course page
        format.html { redirect_to @course, notice: "Course was successfully created." }
        format.json { render :show, status: :created, location: @course }
      else
        # Re-render the new course form. The view already contains
        # logic to display the errors in @course.errors
        format.html { render :new, status: :unprocessable_entity }
        format.json { render json: @course.errors, status: :unprocessable_entity }
      end
    end
  end
```

Now return to the new course form and try submitting the form again with an invalid course id. You should see an error message displayed on the form.

### Creating an enrollment form
After some discussion with Dream of Code staff, we learn that on the enrollment form, the user should be able to select an existing student to enroll from a dropdown, but there should also be an option to enroll a student that hasn't yet taken any Dream of Code classes. So this form will also create the student record in this case.

Here's our wireframe for the form:

TODO wireframe for enrollment form (student dropdown + add student form option)

We're displaying a form and submitting a form, just like when creating a course, so we'll need a GET route to display the form, and a POST route for the form submission. Since an enrollment is a resource in our app, we can use the Rails conventions for these routes.

#### Resource routes and scaffolding
Now that we're comfortable with the structure of routes, we'll start using the convenience method for resources when it makes sense. For enrollments, each of the seven routes generated by the `resources` method is likely to be of use in our application, as we can imagine we'll need to create and enrollment, view an enrollment, list all enrollments, update and enrollment and delete and enrollment at some point. So let's add this to `config/routes.rb`

```
resources :enrollments
```

We've also seen that when implementing CRUD for resources, we follow the same patterns, creating the model, view, controller, migration, routes, etc all carefully following conventions Rails expects. The `rails` executable offers generators that can build any or all of this "scaffolding" for a resource in one command. You can read about generators in the [Rails Guides](https://guides.rubyonrails.org/command_line.html#bin-rails-generate). Let's use a generator to create the enrollments controller.

Anytime we use a command line tool, we'll need to check the options available to be sure we know what we're getting. Very often, you can access options by running the command with a help flag `--help` following:
```
bin/rails generate controller --help

```
Take a minute or two to look over the output. You'll see we also have Rspec options because we have rspec-rails installed. Ruby gems built for Rails will frequently add functionality to Rails generators, which makes the tools easier for Rails developers to use, since the patterns are familiar.

In the description section, you'll see that both the controller and views will be created with this command. You can see that there are a lot of different types of rspec specs that the command will create by default. We aren't writing view specs, routing specs or helper specs for this app, so let's skip those. Also, we can skip the helper file. If we need that, we can create it later.

```
bin/rails generate controller enrollments --no-view-specs --no-routing-specs --no-helper-specs --no-helper
```

You should see a list of files the generator created. Take a minute to look at them all. Run the specs and read through the test cases. Start the server and navigate to the enrollments routes.

So we have a good starting point for our enrollments form, but it's not quite what we need for our app. This is common. It's rare that the default views, routes and controller actions will be exactly the functionality we need. (If it was, we could probably just use Airtable or something similar.)

Let's adjust the form:

TODO html for form

We need to display existing students on the form

TODO get students for form

Now we need to adjust what happens on submit

TODO create enrollment and possibly student

